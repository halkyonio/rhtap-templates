= RHTAP Templates
:icons: font
:revdate: {docdate}
:toc: left
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Introduction

This project contains the code source needed to demo buildpack on RHTAP such as:

* Quarkus REST service exposing a Hello endpoint `/hello` and `+/hello/greeting/{name}+`
* Tekton PipelineRun able to build a container image using buildpack.

== Prerequisite

- Have access to RHTAP: https://console.redhat.com/preview/hac/
- Have kubectl and oc clients installed on your machine
- Switched to the kubernetes context of appstudio

== Env variables

In order to play/execute the commands defined hereafter, it is needed to define some env variables. 
Feel free to change them according to your GitHub organisation, tenant namespace, etc

[,bash]
----
GITHUB_ORG_NAME=halkyonio
GITHUB_REPO_TEMPLATE=rhtap-templates // TODO: Change the code to create a repository from a template
GITHUB_REPO_DEMO_NAME=rhtap-buildpack-demo-1
GITHUB_REPO_DEMO_TITLE="RHTAP Buildpack Demo 1"
BRANCH=main
APPLICATION_NAME=$GITHUB_REPO_DEMO_NAME
COMPONENT_NAME="quarkus-hello"
PAC_NAME=$COMPONENT_NAME
PAC_YAML_FILE=".tekton/$GITHUB_REPO_DEMO_NAME-push.yaml"
TENANT_NAMESPACE=<YOUR_TENANT_NAMESPACE>
REGISTRY_URL=quay.io/redhat-user-workloads/$TENANT_NAMESPACE/$GITHUB_REPO_DEMO_NAME/$COMPONENT_NAME

# NOT YET TESTED: REGISTRY_URL=quay.io/$GITHUB_ORG_NAME/$GITHUB_REPO_DEMO_NAME !!
----

== HowTo

To create a new GitHub repository and import the needed files, perform the following actions:

* Git auth
`gh auth login --with-token <YOUR_GITHUB_TOKEN>`

* Create a GitHub repository

[,bash]
----
gh repo delete $GITHUB_ORG_NAME/$GITHUB_REPO_DEMO_NAME --yes
gh repo create $GITHUB_ORG_NAME/$GITHUB_REPO_DEMO_NAME --public

rm -rf $GITHUB_REPO_DEMO_NAME; mkdir $GITHUB_REPO_DEMO_NAME
cd $GITHUB_REPO_DEMO_NAME

git init
echo "## RHTAP Buildpack Demo 1" > README.md
git add .

echo "## Import runtime code"
wget https://github.com/$GITHUB_ORG_NAME/$GITHUB_REPO_TEMPLATE/archive/$BRANCH.zip
unzip $BRANCH.zip
mv $GITHUB_REPO_TEMPLATE-$BRANCH/$COMPONENT_NAME/.mvn/ .
mv $GITHUB_REPO_TEMPLATE-$BRANCH/$COMPONENT_NAME/* .

echo "$GITHUB_REPO_TEMPLATE-$BRANCH/" > .gitignore
echo "$BRANCH.zip" >> .gitignore
echo "target/" >> .gitignore

git add .
git commit -m "Upload quarkus hello runtime"

git branch -M main
git remote add origin git@github.com:$GITHUB_ORG_NAME/$GITHUB_REPO_DEMO_NAME.git
git push -u origin main
----

* Test locally the quarkus project and access using curl (or httpie) the endpoints (optional)

[,bash]
----
mvn clean compile; mvn quarkus:dev

http :8080/hello
http :8080/hello/greeting/charles
----

* Create a `.Tekton` folder

[,bash]
----
mkdir .tekton
mv $GITHUB_REPO_TEMPLATE-$BRANCH/tekton/template-push.yaml .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml
git add .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml
----

* Customize the RHTAP PipelineRun

[,bash]
----
sed -i.bak "s/#APPLICATION_NAME#/$APPLICATION_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#COMPONENT_NAME#/$COMPONENT_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#PAC_NAME#/$PAC_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#TENANT_NAMESPACE#/$TENANT_NAMESPACE/g" $PAC_YAML_FILE
sed -i.bak "s|#REGISTRY_URL#|$REGISTRY_URL|g" $PAC_YAML_FILE
rm $PAC_YAML_FILE.bak
git commit -sm "Add the tekton push file" .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml; git push
----

* Create the following Application CR and Component CR

[,bash]
----
cat <<EOF | kubectl apply -n $TENANT_NAMESPACE -f -
---
apiVersion: appstudio.redhat.com/v1alpha1
kind: Application
metadata:
  name: $GITHUB_REPO_DEMO_NAME
spec:
  appModelRepository:
    url: ""
  displayName: $GITHUB_REPO_DEMO_NAME
  gitOpsRepository:
    url: ""
---
apiVersion: appstudio.redhat.com/v1alpha1
kind: Component
metadata:
  annotations:
    #applicationFailCounter: "0"
    #appstudio.openshift.io/component-initial-build: processed
    #appstudio.openshift.io/pac-provision: done
    image.redhat.com/generate: '{"visibility":"public"}'
  name: $COMPONENT_NAME
spec:
  application: $GITHUB_REPO_DEMO_NAME
  componentName: $COMPONENT_NAME
  #containerImage: quay.io/redhat-user-workloads/$TENANT_NAMESPACE/$GITHUB_REPO_DEMO_NAME/$COMPONENT_NAME
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 100Mi
  source:
    git:
      context: ./
      devfileUrl: https://raw.githubusercontent.com/devfile-samples/devfile-sample-code-with-quarkus/main/devfile.yaml
      #dockerfileUrl: https://raw.githubusercontent.com/devfile-samples/devfile-sample-code-with-quarkus/main/src/main/docker/Dockerfile.jvm.staged
      revision: main
      url: https://github.com/halkyonio/$GITHUB_REPO_DEMO_NAME.git
  targetPort: 8081
EOF
----

* Alternatively, Import it as documented here: https://redhat-appstudio.github.io/docs.appstudio.io/Documentation/main/how-to-guides/Import-code/proc_importing_code/

* Cleaning

[,bash]
----
kubectl delete application/$GITHUB_REPO_DEMO_NAME
rm $BRANCH.zip; rm -r $GITHUB_REPO_TEMPLATE-$BRANCH
----

== Issue

=== Full image path not supported

The lifecycle component and most probably google container library (used by lifecycle to access the registry) do not support such advanced feature: https://kubernetes.io/docs/concepts/containers/images/#kubelet-credential-provider
The consequence is that if several secrets are attached to the `appstudio-pipeline` service account and subsequently by the pod running lifecycle, then
lifecycle, at the analysis step, will raise an issue if it doesn't get as first entry of the `auths:` config file (from mounted secrets) the full image path matching the image name declared
as output image.

To work around the issue of the full image path not supported by lifecycle (and google-containr), path the secret

[,bash]
----
CFG=$(cat <<EOF
{"auths":{"quay.io":{"auth":"cmVkaGF0LXVzZXItd29ya2xvYWRzK2Ntb3VsbGlhLXRlbmFudHJodGFwLWJ1aWxkcGFjay1kZW1vLTFxdWFya3VzLWhlbGxvOkE0NjFMWkw0UVlCV0VPWFhNRlRYMEpVQjY3TTBTSjlFNjQ4QkE5Q0Q3OEo1M0tEMTBRUEdCMEdJMTlaRkFGNTQ="}}}
EOF
)

SECRET_NAME=$COMPONENT_NAME
TENANT_NAMESPACE="cmoullia-tenant"
PATCH_STRING="[{'op': 'replace', 'path': '/data/.dockerconfigjson', 'value': '$BASE64_ENCODED_VALUE'}]"

kubectl get secret $SECRET_NAME -n $TENANT_NAMESPACE$$ -o json | jq --arg new_val "$(echo -n $CFG | base64)" '.data[".dockerconfigjson"]=$new_val' | kubectl apply -f -
----
