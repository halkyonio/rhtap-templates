= RHTAP Templates
:icons: font
:revdate: {docdate}
:toc: left
:toclevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Introduction

This template project contains the code source needed to build runtimes using Tekton pipelines:

* Quarkus REST service exposing a Hello endpoint `/hello` and `+/hello/greeting/{name}+`
* Tekton PipelineRun able to build a container image (buildpack).

== Prerequisite

- Have access to RHTAP: https://console.redhat.com/preview/hac/
- Have kubectl and oc clients installed on your machine
- Switched to the kubernetes context of appstudio
- Add the `AppStudio` GitHub application to your GitHubOrg and select it to be used for all the repositories

== Env variables

In order to play/execute the commands defined hereafter, it is needed to define some env variables. 
Feel free to change them according to your GitHub organisation, tenant namespace, etc

[,bash]
----
GITHUB_ORG_NAME=halkyonio
GITHUB_REPO_TEMPLATE=rhtap-templates
GITHUB_REPO_DEMO_NAME=rhtap-buildpack-demo-1
GITHUB_REPO_DEMO_TITLE="RHTAP Buildpack Demo 1"
BRANCH=main
APPLICATION_NAME=$GITHUB_REPO_DEMO_NAME
COMPONENT_NAME="quarkus-hello"
PAC_NAME=$COMPONENT_NAME
PAC_YAML_FILE=".tekton/$GITHUB_REPO_DEMO_NAME-push.yaml"
TENANT_NAMESPACE="<YOUR_TENANT_NAMESPACE>"
REGISTRY_URL=quay.io/redhat-user-workloads/$TENANT_NAMESPACE/$GITHUB_REPO_DEMO_NAME/$COMPONENT_NAME
BUILD_ID=1 # ID used to generate the following kubernetes label's value: test-01 for rhtap.snowdrop.deb/build
----

== HowTo

To create a new GitHub repository and import the needed files, perform the following actions:

* Git auth
`gh auth login --with-token <YOUR_GITHUB_TOKEN>`

* Create a GitHub repository

[,bash]
----
gh repo delete $GITHUB_ORG_NAME/$GITHUB_REPO_DEMO_NAME --yes
gh repo create --template https://github.com/$ORG_NAME/$REPO_TEMPLATE --clone $ORG_NAME/$REPO_DEMO_NAME --public

rm -rf $GITHUB_REPO_DEMO_NAME
git clone git@github.com:$ORG_NAME/$REPO_DEMO_NAME
cd $REPO_DEMO_NAME
----

* Test locally the quarkus project and access using curl (or httpie) the endpoints (optional)

[,bash]
----
mvn clean compile; mvn quarkus:dev

# In a separate terminal, execute such httpie (or curl) commands
http :8080/hello
http :8080/hello/greeting/charles
----

* Get the RHTAP pipelineRun and rename the template file

[,bash]
----
mkdir .tekton
cp tekton/pipelinerun-rhtap-buildpack.yaml .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml
git add .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml
git commit -asm "Add the PipelineRun"
git push
----

* Customize the RHTAP PipelineRun

[,bash]
----
sed -i.bak "s/#APPLICATION_NAME#/$APPLICATION_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#COMPONENT_NAME#/$COMPONENT_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#PAC_NAME#/$PAC_NAME/g" $PAC_YAML_FILE
sed -i.bak "s/#TENANT_NAMESPACE#/$TENANT_NAMESPACE/g" $PAC_YAML_FILE
sed -i.bak "s|#REGISTRY_URL#|$REGISTRY_URL|g" $PAC_YAML_FILE
sed -i.bak "s|#BUILD_ID#|$BUILD_ID|g" $PAC_YAML_FILE
rm $PAC_YAML_FILE.bak
git commit -sm "Add the tekton push file" .tekton/$GITHUB_REPO_DEMO_NAME-push.yaml
git push
----

* Create the following Application CR and Component CR

[,bash]
----
cat <<EOF | kubectl apply -n $TENANT_NAMESPACE -f -
---
apiVersion: appstudio.redhat.com/v1alpha1
kind: Application
metadata:
  name: $GITHUB_REPO_DEMO_NAME
spec:
  appModelRepository:
    url: ""
  displayName: $GITHUB_REPO_DEMO_NAME
  gitOpsRepository:
    url: ""
---
apiVersion: appstudio.redhat.com/v1alpha1
kind: Component
metadata:
  annotations:
    image.redhat.com/generate: '{"visibility":"public"}'
  name: $COMPONENT_NAME
spec:
  application: $GITHUB_REPO_DEMO_NAME
  componentName: $COMPONENT_NAME
  replicas: 1
  resources:
    requests:
      cpu: 10m
      memory: 100Mi
  source:
    git:
      context: ./
      devfileUrl: https://raw.githubusercontent.com/devfile-samples/devfile-sample-code-with-quarkus/main/devfile.yaml
      #dockerfileUrl: https://raw.githubusercontent.com/devfile-samples/devfile-sample-code-with-quarkus/main/src/main/docker/Dockerfile.jvm.staged
      revision: main
      url: https://github.com/halkyonio/$GITHUB_REPO_DEMO_NAME.git
  targetPort: 8081
EOF
----

* Check resources created

[,bash]
----
for entity in pods deployments routes services taskruns pipelineruns applications components snapshotenvironmentbinding.appstudio.redhat.com componentdetectionquery.appstudio.redhat.com; do count=$(kubectl -n $TENANT_NAMESPACE get "$entity" -o name | wc -l); echo "$count $entity"; done | sort -n
----

* At this point, a default build will be started as the component created has not been yet customized. To achieve this, it is needed to execute the following additional
steps manually:
- To customize your component, it is needed to `Manage Build pipelines` from the component https://console.redhat.com/preview/hac/application-pipeline/workspaces/cmoullia/applications/rhtap-buildpack-demo-1/components[screen]
- Within the popup window displayed, click on the button `Send PullRequest` and wait a few moment till the PR has been sent to the Github repository
- It is not needed to accept the PR as the project already contains a customized tekton folder
- Close the popup window

You can now open the `activity` and you will see that a custom build has been started for pull and push :-)

* Alternatively, Import it as documented here: https://redhat-appstudio.github.io/docs.appstudio.io/Documentation/main/how-to-guides/Import-code/proc_importing_code/

* Cleaning

[,bash]
----
kubectl delete application/$GITHUB_REPO_DEMO_NAME
rm $BRANCH.zip; rm -r $GITHUB_REPO_TEMPLATE-$BRANCH
----

== Todo

- Try to make a test using our own quay.io credentials and repository using REGISTRY_URL=quay.io/$GITHUB_ORG_NAME

== Issue

=== Full image path not supported

The lifecycle component and most probably google container library (used by lifecycle to access the registry) do not support such advanced feature: https://kubernetes.io/docs/concepts/containers/images/#kubelet-credential-provider
The consequence is that if several secrets are attached to the `appstudio-pipeline` service account and subsequently by the pod running lifecycle, then
lifecycle, at the analysis step, will raise an issue if it doesn't get as first entry of the `auths:` config file (from mounted secrets) the full image path matching the image name declared
as output image.

To work around the issue of the full image path not supported by lifecycle (and google-containr), path the secret

[,bash]
----
CFG=$(cat <<EOF
{"auths":{"quay.io":{"auth":"cmVkaGF0LXVzZXItd29ya2xvYWRzK2Ntb3VsbGlhLXRlbmFudHJodGFwLWJ1aWxkcGFjay1kZW1vLTFxdWFya3VzLWhlbGxvOkE0NjFMWkw0UVlCV0VPWFhNRlRYMEpVQjY3TTBTSjlFNjQ4QkE5Q0Q3OEo1M0tEMTBRUEdCMEdJMTlaRkFGNTQ="}}}
EOF
)

SECRET_NAME=$COMPONENT_NAME
TENANT_NAMESPACE="cmoullia-tenant"
PATCH_STRING="[{'op': 'replace', 'path': '/data/.dockerconfigjson', 'value': '$BASE64_ENCODED_VALUE'}]"

kubectl get secret $SECRET_NAME -n $TENANT_NAMESPACE$$ -o json | jq --arg new_val "$(echo -n $CFG | base64)" '.data[".dockerconfigjson"]=$new_val' | kubectl apply -f -
----
